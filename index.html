<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-han">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="blogs and research">
<meta property="og:type" content="website">
<meta property="og:title" content="shengfq&#39;s blog">
<meta property="og:url" content="https://www.shengfq.github.io/index.html">
<meta property="og:site_name" content="shengfq&#39;s blog">
<meta property="og:description" content="blogs and research">
<meta property="og:locale" content="zn-han">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="shengfq&#39;s blog">
<meta name="twitter:description" content="blogs and research">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.shengfq.github.io/"/>





  <title>shengfq's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-han">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">shengfq's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">an developer using java</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2019/08/21/IO基础(三)-InputStream转String/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/IO基础(三)-InputStream转String/" itemprop="url">javaIO(三)-InputStream与String的转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-21T00:00:00+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们在 Java 中经常会碰到如何把 InputStream 转换成 String 的情形，比如从文件或网络得到一个 InputStream，需要转换成字符串输出或赋给别的变量。</p>
<p>未真正关注这个问题之前我常用的办法就是按字节一次次读到缓冲区，或是建立 BufferedReader 逐行读取。其实大可不必费此周折，我们可以用 Apache commons IOUtils，或者是 JDK 1.5 后的 Scanner，还可用 Google  Guava 库的 CharStreams。到了 JDK7，若要从文件中直接得到字符串还能用 java.nio.file.Files#readAllLines 和 java.nio.file.Files#readAllBytes 方法。</p>
<p>下面看各个例子，为能够实际用运，例子写在 main 方法里，并从文件获得一个 InputStream，代码中把可能要捕获的异常抛出来。再就是注意处理输入输出流时有涉及到字符集，字符集乱了就乱码了，默认字符集是 System.getProperty(“file.encoding”)，通常我们都用 UTF-8，异常 UnsupportedEncodingException 继承自 IOException。</p>
<p>下面的 6 个方法中应该有一个你能看得上的吧，用 Groovy，Scala 的除外，若未找到一个遂意的，告诉我，你有好办法更应该告诉我。</p>
<ol>
<li>使用 JDK 5 的 Scanner</li>
</ol>
<pre>
package cc.unmi.test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Scanner;

/**
 * 
 * @author Unmi
 * @Creation date: 2013-02-01
 */
public class Test {

    /**
     * @param args
     * @throws FileNotFoundException 
     */
    public static void main(String[] args) throws FileNotFoundException {
        InputStream inputStream = new FileInputStream("d:/sample.txt");
        Scanner scanner = new Scanner(inputStream, "UTF-8");
        String text = scanner.useDelimiter("\\A").next();
        System.out.println(text);
        scanner.close();
    }
}
</pre>
2. JDK1.4 及之前的 BufferedReader 法

<pre>
package cc.unmi.test;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

/**
 * 
 * @author Unmi
 * @Creation date: 2013-02-01
 */
public class Test {

    /**
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        InputStream inputStream = new FileInputStream("d:/sample.txt");
        StringBuilder stringBuilder = new StringBuilder();
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));
        boolean firstLine = true;
        String line = null; ;
        while((line = bufferedReader.readLine()) != null){
            if(!firstLine){
                stringBuilder.append(System.getProperty("line.separator"));
            }else{
                firstLine = false;
            }
            stringBuilder.append(line);
        }
        System.out.println(stringBuilder.toString());
    }
}
</pre>
中间那些判断是不是第一行来决定是否加换行符是些杂音。
<br>

3. JDK1.4 及之前的 readBytes 法
<pre>
package cc.unmi.test;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * 
 * @author Unmi
 * @Creation date: 2013-02-01
 */
public class Test {

    /**
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        InputStream inputStream = new FileInputStream("d:/sample.txt");

        byte[] buffer = new byte[2048];
        int readBytes = 0;
        StringBuilder stringBuilder = new StringBuilder();
        while((readBytes = inputStream.read(buffer)) > 0){
            stringBuilder.append(new String(buffer, 0, readBytes));
        }

        System.out.println(stringBuilder.toString());
    }
}

</pre>
缓冲区的大小自己根据实际来调，比 BufferedReader 还简洁些，不需管换行符的事情。<br>

4. Apache commons IOUtils.toString 法

<pre>
package cc.unmi.test;

import java.io.*;

import org.apache.commons.io.IOUtils;

/**
 * 
 * @author Unmi
 * @Creation date: 2013-02-01
 */
public class Test {

    /**
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        InputStream inputStream = new FileInputStream("d:/sample.txt");
        String text = IOUtils.toString(inputStream);
        System.out.println(text);
    }
}
</pre>
第三方库就是第三方库，人家充分考虑到了你的感受，你对 JDK 库的抱怨，多简洁，一行搞定。IOUtils 还能把内容拷入其他的 Writer 中，如 
<pre>
IOUtils.copy(inputStream, new StringWriter())。
</pre>
<br>

5. Google guava 的  CharStreams 方法

<pre>
package cc.unmi.test;

import java.io.*;

import com.google.common.io.CharStreams;

/**
 * 
 * @author Unmi
 * @Creation date: 2013-02-01
 */
public class Test {

    /**
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        InputStream inputStream = new FileInputStream("d:/sample.txt");
        String text = CharStreams.toString(new InputStreamReader(inputStream, "UTF-8"));
        System.out.println(text);
    }
}
</pre>

<p>CharSteams 不是直接作用在 InputSteam 上的，还要靠 InputStreamReader 拱个桥。<br><br></p>
<ol start="6">
<li>JDK 7 的 NIO readAllBytes</li>
</ol>
<pre>

package cc.unmi.test;

import java.io.IOException;
import java.nio.file.*;

/**
 * 
 * @author Unmi
 * @Creation date: 2013-02-01
 */

public class Test {

    /**
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
        byte[] bytes = Files.readAllBytes(Paths.get("d:/sample.txt"));
        String text = new String(bytes);
        System.out.println(text);
    }
}
</pre>

<h2 id=""><a href="#" class="headerlink" title=""></a><span></span></h2><p>这让我们相信 JDK  一直还有人在管，虽然不可能象动态语言的方法那么快捷，上面的  readAllBytes 在处理大文件时肯定会很被动的。而 Files.readAllLines 会把文件的内容读入一个 List<string> 对象中，往内存不断放东西就得掂量下内存会不会被爆。在 java.nio.file.* 还有很多新事物可供发掘。<br></string></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2019/08/21/(Reactor)异步非阻塞多路IO复用模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/(Reactor)异步非阻塞多路IO复用模型/" itemprop="url">(Reactor)异步非阻塞多路IO复用模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-21T00:00:00+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>异步非阻塞多路I/O复用机制<br>这个名词可以理解为NIO,是比同步阻塞模型响应更加快速的线程模型,为什么要理解他?<br>因为Redis,Nginx,Netty的线程模型都是在此基础上构建的.</p>
<p>需要基础:Linux,JAVA IO,JAVA NIO,JAVA SOCKET,JAVA.UTIL.CONCURRENT.*;</p>
<p>文章原文链接:&lt;a href=<a href="http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html&gt;点我访问" target="_blank" rel="noopener">http://www.blogjava.net/DLevin/archive/2015/09/02/427045.html&gt;点我访问</a> </p>
<p><br><br>1. Reactor模式详解<br>前记<br>第一次听到Reactor模式是三年前的某个晚上，一个室友突然跑过来问我什么是Reactor模式？我上网查了一下，很多人都是给出NIO中的 Selector的例子，而且就是NIO里Selector多路复用模型，只是给它起了一个比较fancy的名字而已，虽然它引入了EventLoop概 念，这对我来说是新的概念，但是代码实现却是一样的，因而我并没有很在意这个模式。然而最近开始读Netty源码，而Reactor模式是很多介绍Netty的文章中被大肆宣传的模式，因而我再次问自己，什么是Reactor模式？本文就是对这个问题关于我的一些理解和尝试着来解答。<br><br>2. 什么是Reactor模式<br>要回答这个问题，首先当然是求助Google或Wikipedia，其中Wikipedia上说：“The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers.”。从这个描述中，我们知道Reactor模式首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler。如果用图来表达：<br><br>从结构上，这有点类似生产者消费者模式，即有一个或多个生产者将事件放入一个Queue中，而一个或多个消费者主动的从这个Queue中Poll事件来处理；而Reactor模式则并没有Queue来做缓冲，每当一个Event输入到Service Handler之后，该Service Handler会主动的根据不同的Event类型将其分发给对应的Request Handler来处理。<br><br>更学术的，这篇文章&lt;a href=<a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf&gt;（Reactor" target="_blank" rel="noopener">http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf&gt;（Reactor</a> An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events）上说：<br><br>“The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. Each service in an application may consistent of several methods and is represented by a separate event handler that is responsible for dispatching service-specific requests. Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. Demultiplexing of service requests is performed by a synchronous event demultiplexer. Also known as Dispatcher, Notifier”。<br></p><p><br>这段描述和Wikipedia上的描述类似，有多个输入源，有多个不同的EventHandler（RequestHandler）来处理不同的请求，Initiation Dispatcher用于管理EventHander，EventHandler首先要注册到Initiation Dispatcher中，然后Initiation Dispatcher根据输入的Event分发给注册的EventHandler；然而Initiation Dispatcher并不监听Event的到来，这个工作交给Synchronous Event Demultiplexer来处理。<br>Reactor模式结构<br>在解决了什么是Reactor模式后，我们来看看Reactor模式是由什么模块构成。图是一种比较简洁形象的表现方式，因而先上一张图来表达各个模块的名称和他们之间的关系：<br>&lt;img src=<a href="http://www.blogjava.net/images/blogjava_net/dlevin/Reactor_Structures.png" target="_blank" rel="noopener">http://www.blogjava.net/images/blogjava_net/dlevin/Reactor_Structures.png</a> /&gt;<br></p><p><br><b>Handle</b>：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到Synchronous Event Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。<br><br><b>Synchronous Event Demultiplexer</b>：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。在Java NIO中用Selector来封装，当Selector.select()返回时，可以调用Selector的selectedKeys()方法获取Set<selectionkey>，一个SelectionKey表达一个有事件发生的Channel以及该Channel上的事件类型。上图的“Synchronous Event Demultiplexer —notifies–&gt; Handle”的流程如果是对的，那内部实现应该是select()方法在事件到来后会先设置Handle的状态，然后返回。不了解内部实现机制，因而保留原图。<br><br><b>Initiation Dispatcher</b>：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。<br><br><b>Event Handler</b>：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。<br><br><b>Concrete Event Handler</b>：事件EventHandler接口，实现特定事件处理逻辑。<br><br><br><b>Reactor模式模块之间的交互</b><br>简单描述一下Reactor各个模块之间的交互流程，先从序列图开始：<br>&lt;img src=<a href="http://www.blogjava.net/images/blogjava_net/dlevin/Reactor_Sequence.png" target="_blank" rel="noopener">http://www.blogjava.net/images/blogjava_net/dlevin/Reactor_Sequence.png</a> /&gt;<br><br>1. 初始化InitiationDispatcher，并初始化一个Handle到EventHandler的Map。<br>2. 注册EventHandler到InitiationDispatcher中，每个EventHandler包含对相应Handle的引用，从而建立Handle到EventHandler的映射（Map）。<br>3. 调用InitiationDispatcher的handle_events()方法以启动Event Loop。在Event Loop中，调用select()方法（Synchronous Event Demultiplexer）阻塞等待Event发生。<br>4. 当某个或某些Handle的Event发生后，select()方法返回，InitiationDispatcher根据返回的Handle找到注册的EventHandler，并回调该EventHandler的handle_events()方法。<br>5. 在EventHandler的handle_events()方法中还可以向InitiationDispatcher中注册新的Eventhandler，比如对AcceptorEventHandler来，当有新的client连接时，它会产生新的EventHandler以处理新的连接，并注册到InitiationDispatcher中。<br><br><b>Reactor模式实现</b><br>在Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events中，一直以Logging Server来分析Reactor模式，这个Logging Server的实现完全遵循这里对Reactor描述，因而放在这里以做参考。Logging Server中的Reactor模式实现分两个部分：Client连接到Logging Server和Client向Logging Server写Log。因而对它的描述分成这两个步骤。<br><br><br><b>Client连接到Logging Server</b><br>&lt;img src=<a href="http://www.blogjava.net/images/blogjava_net/dlevin/Reactor_LoggingServer_connect.png" target="_blank" rel="noopener">http://www.blogjava.net/images/blogjava_net/dlevin/Reactor_LoggingServer_connect.png</a> /&gt;<br><br>1. Logging Server注册LoggingAcceptor到InitiationDispatcher。<br>2. Logging Server调用InitiationDispatcher的handle_events()方法启动。<br>3. InitiationDispatcher内部调用select()方法（Synchronous Event Demultiplexer），阻塞等待Client连接。<br>4. Client连接到Logging Server。<br>5. InitiationDisptcher中的select()方法返回，并通知LoggingAcceptor有新的连接到来。<br>6. LoggingAcceptor调用accept方法accept这个新连接。<br>7. LoggingAcceptor创建新的LoggingHandler。<br>8. 新的LoggingHandler注册到InitiationDispatcher中(同时也注册到Synchonous Event Demultiplexer中)，等待Client发起写log请求。<br><br><b>Client向Logging Server写Log</b><br>&lt;img src=<a href="http://www.blogjava.net/images/blogjava_net/dlevin/Reactor_LoggingServer_log.png" target="_blank" rel="noopener">http://www.blogjava.net/images/blogjava_net/dlevin/Reactor_LoggingServer_log.png</a> /&gt;<br><br>1. Client发送log到Logging server。<br>2. InitiationDispatcher监测到相应的Handle中有事件发生，返回阻塞等待，根据返回的Handle找到LoggingHandler，并回调LoggingHandler中的handle_event()方法。<br>3. LoggingHandler中的handle_event()方法中读取Handle中的log信息。<br>4. 将接收到的log写入到日志文件、数据库等设备中。<br>3.4步骤循环直到当前日志处理完成。<br>5. 返回到InitiationDispatcher等待下一次日志写请求。<br><br>在Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events有对Reactor模式的C++的实现版本，多年不用C++，因而略过。 <br><br><br><b>Java NIO对Reactor的实现</b><br><br>在Java的NIO中，对Reactor模式有无缝的支持，即使用Selector类封装了操作系统提供的Synchronous Event Demultiplexer功能。这个Doug Lea已经在Scalable IO In Java中有非常深入的解释了，因而不再赘述，另外&lt;a href=<a href="http://www.cnblogs.com/luxiaoxun/archive/2015/03/11/4331110.html&gt;这篇文章" target="_blank" rel="noopener">http://www.cnblogs.com/luxiaoxun/archive/2015/03/11/4331110.html&gt;这篇文章</a>对Doug Lea的Scalable IO In Java有一些简单解释，至少它的代码格式比Doug Lea的PPT要整洁一些。<br><p><br>需要指出的是，不同这里使用InitiationDispatcher来管理EventHandler，在Doug Lea的版本中使用SelectionKey中的Attachment来存储对应的EventHandler，因而不需要注册EventHandler这个步骤，或者设置Attachment就是这里的注册。而且在这篇文章中，Doug Lea从单线程的Reactor、Acceptor、Handler实现这个模式出发；演化为将Handler中的处理逻辑多线程化，实现类似Proactor模式，此时所有的IO操作还是单线程的，因而再演化出一个Main Reactor来处理CONNECT事件(Acceptor)，而多个Sub Reactor来处理READ、WRITE等事件(Handler)，这些Sub Reactor可以分别再自己的线程中执行，从而IO操作也多线程化。这个最后一个模型正是Netty中使用的模型。并且在Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events的9.5 Determine the Number of Initiation Dispatchers in an Application中也有相应的描述。<br></p>

<p><b>EventHandler接口定义</b></p>
<p>对EventHandler的定义有两种设计思路：single-method设计和multi-method设计：<br><br>A single-method interface：它将Event封装成一个Event Object，EventHandler只定义一个handle_event(Event event)方法。这种设计的好处是有利于扩展，可以后来方便的添加新的Event类型，然而在子类的实现中，需要判断不同的Event类型而再次扩展成 不同的处理方法，从这个角度上来说，它又不利于扩展。另外在Netty3的使用过程中，由于它不停的创建ChannelEvent类，因而会引起GC的不稳定。<br><br>A multi-method interface：这种设计是将不同的Event类型在 EventHandler中定义相应的方法。这种设计就是Netty4中使用的策略，其中一个目的是避免ChannelEvent创建引起的GC不稳定， 另外一个好处是它可以避免在EventHandler实现时判断不同的Event类型而有不同的实现，然而这种设计会给扩展新的Event类型时带来非常 大的麻烦，因为它需要该接口。<br></p>
<p><b>关于Netty4对Netty3的改进可以参考这里</b>：</p>
<p>ChannelHandler with no event object<br>In 3.x, every I/O operation created a ChannelEvent object. For each read / write, it additionally created a new ChannelBuffer. It simplified the internals of Netty quite a lot because it delegates resource management and buffer pooling to the JVM. However, it often was the root cause of GC pressure and uncertainty which are sometimes observed in a Netty-based application under high load.<br>4.0 removes event object creation almost completely by replacing the event objects with strongly typed method invocations. 3.x had catch-all event handler methods such as handleUpstream() and handleDownstream(), but this is not the case anymore. Every event type has its own handler method now:</p>
<p><b>为什么使用Reactor模式</b></p>
<p>归功与Netty和Java NIO对Reactor的宣传，本文慕名而学习的Reactor模式，因而已经默认Reactor具有非常优秀的性能，然而慕名归慕名，到这里，我还是要不得不问自己Reactor模式的好处在哪里？即为什么要使用这个Reactor模式？<br></p>
<p>在Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events中是这么说的：<br>Reactor Pattern优点<br>Separation of concerns: The Reactor pattern decouples application-independent demultiplexing and dispatching mechanisms from application-specific hook method functionality. The application-independent mechanisms become reusable components that know how to demultiplex events and dispatch the appropriate hook methods defined by Event Handlers. In contrast, the application-specific functionality in a hook method knows how to perform a particular type of service.</p>
<p>Improve modularity, reusability, and configurability of event-driven applications: The pattern decouples application functionality into separate classes. For instance, there are two separate classes in the logging server: one for establishing connections and another for receiving and processing logging records. This decoupling enables the reuse of the connection establishment class for different types of connection-oriented services (such as file transfer, remote login, and video-on-demand). Therefore, modifying or extending the functionality of the logging server only affects the implementation of the logging handler class.</p>
<p>Improves application portability: The Initiation Dispatcher’s interface can be reused independently of the OS system calls that perform event demultiplexing. These system calls detect and report the occurrence of one or more events that may occur simultaneously on multiple sources of events. Common sources of events may in- clude I/O handles, timers, and synchronization objects. On UNIX platforms, the event demultiplexing system calls are called select and poll [1]. In the Win32 API [16], the WaitForMultipleObjects system call performs event demultiplexing.</p>
<p>Provides coarse-grained concurrency control: The Reactor pattern serializes the invocation of event handlers at the level of event demultiplexing and dispatching within a process or thread. Serialization at the Initiation Dispatcher level often eliminates the need for more complicated synchronization or locking within an application process.</p>
<p><b>这些貌似是很多模式的共性：解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制等，因而并不能很好的说明什么，特别是它鼓吹的对性能的提升，这里并没有体现出来。</b><br><br>当然在这篇文章的开头有描述过另一种直观的实现：Thread-Per-Connection，即传统的实现，提到了这个传统实现的以下问题：</p>
<font color="red">Thread Per Connection缺点</font><br><br>Efficiency: Threading may lead to poor performance due to context switching, synchronization, and data movement [2];<br><br>Programming simplicity: Threading may require complex concurrency control schemes;<br><br>Portability: Threading is not available on all OS platforms.<br>对于性能，它其实就是第一点关于Efficiency的描述，即线程的切换、同步、数据的移动会引起性能问题。也就是说从性能的角度上，它最大的提升就是减少了性能的使用，即不需要每个Client对应一个线程。我的理解，其他业务逻辑处理很多时候也会用到相同的线程，IO读写操作相对CPU的操作还是要慢很多，即使Reactor机制中每次读写已经能保证非阻塞读写，这里可以减少一些线程的使用，但是这减少的线程使用对性能有那么大的影响吗？答案貌似是肯定的，这篇论文(SEDA: Staged Event-Driven Architecture - An Architecture for Well-Conditioned, Scalable Internet Service)对随着线程的增长带来性能降低做了一个统计：<br><br>在这个统计中，每个线程从磁盘中读8KB数据，每个线程读同一个文件，因而数据本身是缓存在操作系统内部的，即减少IO的影响；所有线程是事先分配的，不会有线程启动的影响；所有任务在测试内部产生，因而不会有网络的影响。该统计数据运行环境：Linux 2.2.14，2GB内存，4-way 500MHz Pentium III。从图中可以看出，随着线程的增长，吞吐量在线程数为8个左右的时候开始线性下降，并且到64个以后而迅速下降，其相应事件也在线程达到256个后指数上升。即1+1&lt;2，因为线程切换、同步、数据移动会有性能损失，线程数增加到一定数量时，这种性能影响效果会更加明显。<br><br>对于这点，还可以参考C10K Problem，用以描述同时有10K个Client发起连接的问题，到2010年的时候已经出现10M Problem了。<br><br>当然也有人说：Threads are expensive are no longer valid.在不久的将来可能又会发生不同的变化，或者这个变化正在、已经发生着？没有做过比较仔细的测试，因而不敢随便断言什么，然而本人观点，即使线程变的影响并没有以前那么大，使用Reactor模式，甚至时SEDA模式来减少线程的使用，再加上其他解耦、模块化、提升复用性等优点，还是值得使用的。<br><br><br><font color="red">Reactor模式的缺点</font>

<p>Reactor模式的缺点貌似也是显而易见的：</p>
<ol>
<li>相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。</li>
<li>Reactor模式需要底层的Synchronous Event Demultiplexer支持，比如Java中的Selector支持，操作系统的select系统调用支持，如果要自己实现Synchronous Event Demultiplexer可能不会有那么高效。</li>
<li>Reactor模式在IO读写数据时还是在同一个线程中实现的，即使使用多个Reactor机制的情况下，那些共享一个Reactor的Channel如果出现一个长时间的数据读写，会影响这个Reactor中其他Channel的相应时间，比如在大文件传输时，IO操作就会影响其他Client的相应时间，因而对这种操作，使用传统的Thread-Per-Connection或许是一个更好的选择，或则此时使用Proactor模式。</li>
</ol>
<p></p><h4>参考</h4><br>Reactor Pattern WikiPedia <br><br>Reactor An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events<br><br>Scalable IO In Java<br><br>C10K Problem WikiPedia<br></selectionkey></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2019/08/21/Netty应运而生/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/Netty应运而生/" itemprop="url">Netty 应运而生</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-21T00:00:00+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b>导读</b></p>
<p></p><p><br>Netty 服务端创建需要的必备知识如下：</p>
<ol>
<li>熟悉 JDK NIO 主要类库的使用，例如 ByteBuffer、Selector</li>
<li>ServerSocketChannel 等；</li>
<li>熟悉 JDK 的多线程编程；</li>
<li>了解 Reactor 模式。</li>
</ol>
<p><b>需求</b><br>如果需要构建基于NIO的高性能,异步,高可靠的底层通讯框架. 开发高质量的 NIO 程序并不是一件简单的事情，除去 NIO 类库的固有复杂性和 Bug，作为 NIO 服务端，需要能够处理网络的闪断、客户端的重连、安全认证和消息的编解码、半包处理等。如果没有足够的 NIO 编程经验积累，自研 NIO 框架往往需要半年甚至数年的时间才能最终稳定下来，这种成本即便对一个大公司而言也是个严重的挑战。</p>
<p>&lt;img src=<a href="https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfMk7VlIOcRXdVsmAGiaQuf3zbINzsTAJuWAkQkQC6HQJCribfX4QQV7o3uwa23wlfibgkfPS97sKcDeA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" target="_blank" rel="noopener">https://mmbiz.qpic.cn/mmbiz_png/FE4VibF0SjfMk7VlIOcRXdVsmAGiaQuf3zbINzsTAJuWAkQkQC6HQJCribfX4QQV7o3uwa23wlfibgkfPS97sKcDeA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1</a> /&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2019/08/18/集合框架详解一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/集合框架详解一/" itemprop="url">集合框架总结一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T00:00:00+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##1. 集合的定义<br>什么是集合呢？<br><br>定义：集合是一个存放对象的引用的容器。<br>在Java中，集合位于java.util包下。<br></p>
<p>##2. 集合和数组的区别(面试常问)<br>提到容器，就会想起数组，那么集合和数组的区别是什么呢？（这里是重点，面试可能问的比较多）</p>
<li>数组和集合都是Java中的容器<br><br></li><li>数组的长度是固定的，集合的长度是可变的<br><br></li><li>数组只能存储相同数据类型的数据，这里的数据类型可以是基本数据类型，也可以是引用类型<br><br></li><li>集合可以存储不同数据类型的对象的引用(但一般情况下，我们会使用泛型来约定只使用1种数据类型)，但不能存储基本数据类型<br><br><br>空口无凭，我们来点代码配合理解，首先，我们看下如下的数组代码：<br><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] platformArray = new String[3];</span><br><span class="line">platformArray[0] = &quot;博客园&quot;;</span><br><span class="line">platformArray[1] = &quot;掘金&quot;;</span><br><span class="line">platformArray[2] = &quot;微信公众号&quot;;</span><br><span class="line">platformArray[3] = &quot;个人博客&quot;;</span><br></pre></td></tr></table></figure><br><br>复制代码运行代码就会发现<br><br><pre>platformArray[3] = “个人博客”;</pre>会引发java.lang.ArrayIndexOutOfBoundsException异常。<br><br>而使用集合时就不存在这个问题，因为集合在声明时不需要指定长度并且长度会根据放入元素的多少而变化：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; platformList = new ArrayList&lt;&gt;();</span><br><span class="line">platformList.add(&quot;博客园&quot;);</span><br><span class="line">platformList.add(&quot;掘金&quot;);</span><br><span class="line">platformList.add(&quot;微信公众号&quot;);</span><br><span class="line">platformList.add(&quot;个人博客&quot;);</span><br><span class="line">复制代码观察上面声明数组的代码，我们可以推断出下面的代码肯定是编译不通过的：</span><br><span class="line">String[] platformArray = new String[3];</span><br><span class="line">platformArray[0] = &quot;博客园&quot;;</span><br><span class="line">platformArray[1] = &quot;掘金&quot;;</span><br><span class="line">platformArray[2] = 1;</span><br><span class="line">复制代码因为数组声明时用的是String类型，而platformArray[2] = 1;赋值时却使用了int类型。</span><br><span class="line">再来看下下面的集合代码：</span><br><span class="line">List&lt;int&gt; intList = new ArrayList&lt;int&gt;();</span><br><span class="line">intList.add(1);</span><br><span class="line">intList.add(2);</span><br><span class="line">intList.add(3);</span><br><span class="line">复制代码这段代码也是编译不通过的，在IDEA中，鼠标悬停时会提示如下的错误信息：</span><br><span class="line"></span><br><span class="line">意思是类型参数不能是原始类型(基本数据类型)，那怎么使用呢？总不能不让我使用int型的集合吧？</span><br><span class="line">当然不会，Java为每种基本数据类型都提供了对应的包装类，这里修改为int类型对应的包装类Integer即可：</span><br><span class="line">List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">intList.add(1);</span><br><span class="line">intList.add(2);</span><br><span class="line">intList.add(3);</span><br></pre></td></tr></table></figure><br><br>复制代码以下为Java的原始类型(基本数据类型)与其对应的包装类：<br><br><br><br>|原始类型|包装类|<br>| :——– | ——–: |<br>|byte |Byte|<br>|short|Short|<br>|int|Integer|<br>|long|Long|<br>|float|Float|<br>|double|Double|<br>|char|Character|<br>|boolean|Boolean|<br><br>##3. 集合的分类<br>在Java中，集合主要分为以下3种：<br></li><li> List集合</li><br><li>Set集合</li><br><li>Map集合</li>

<p>它们之间的继承关系可以参考下图。</p>
<p>从上图可以总结出如下几点：</p>
<li>Java集合的根接口是Collection，它又继承了迭代接口Iterable</li><br><li>List接口和Set接口继承了Collection接口</li><br><li>Map接口是独立的接口，并没有继承Collection接口  （这里是重点，面试可能问的比较多）</li><br><li>List接口常用的实现类有：ArrayList、LinkedList、Vector</li><br><li>Set接口常用的实现类有：HashSet、LinkedHashSet、TreeSet</li><br><li>Map接口常用的实现类有：HashMap、HashTable、TreeMap</li>

<p>##4. List集合<br>List集合包括List接口以及List接口的所有实现类。List集合具有以下特点：</p>
<p><li>集合中的元素允许重复</li></p>
<p><li>集合中的元素是有顺序的，各元素插入的顺序就是各元素的顺序</li></p>
<p><li>集合中的元素可以通过索引来访问或者设置</li></p>
<p><li>List接口常用的实现类有：ArrayList、LinkedList、Vector。</li></p>
<p>我们先看下如下示例了解下List集合的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Muster &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; strList = new ArrayList&lt;&gt;();</span><br><span class="line">        strList.add(&quot;a&quot;);</span><br><span class="line">        strList.add(&quot;b&quot;);</span><br><span class="line">        strList.add(&quot;c&quot;);</span><br><span class="line"></span><br><span class="line">        int i = (int) (Math.random() * strList.size());</span><br><span class="line">        System.out.println(&quot;随机获取数组中的元素：&quot; + strList.get(i));</span><br><span class="line"></span><br><span class="line">        strList.remove(2);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;将索引为2的元素从列表移除后，数组中的元素是:&quot;);</span><br><span class="line">        for (int j = 0; j &lt; strList.size(); j++) &#123;</span><br><span class="line">            System.out.println(strList.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码以上代码的输出结果为：</p>
<p><pre><br>随机获取数组中的元素：a<br>将索引为2的元素从列表移除后，数组中的元素是:<br>a<br>b<br></pre><br><a href="##"><br>关于List集合的详细用法，ArrayList、LinkedList、Vector的区别（这里是重点，面试可能问的比较多），后续会单独写文总结，敬请期待。<br></a></p>
<p>##5. Set集合<br>Set集合包括Set接口以及Set接口的所有实现类。Set集合具有以下特点：</p>
<p><li>集合中不包含重复元素(你可以重复添加，但只会保留第1个)</li></p>
<p><li>集合中的元素不一定保证有序</li></p>
<p><li>Set接口常用的实现类有：HashSet、LinkedHashSet、TreeSet。</li></p>
<p>我们先看下如下示例了解下Set集合的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Muster &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; platformList = new HashSet&lt;&gt;();</span><br><span class="line">        platformList.add(&quot;博客园&quot;);</span><br><span class="line">        platformList.add(&quot;掘金&quot;);</span><br><span class="line">        platformList.add(&quot;微信公众号&quot;);</span><br><span class="line">        platformList.add(&quot;个人博客&quot;);</span><br><span class="line"></span><br><span class="line">        // 尝试添加重复元素</span><br><span class="line">        platformList.add(&quot;博客园&quot;);</span><br><span class="line">        platformList.add(&quot;掘金&quot;);</span><br><span class="line"></span><br><span class="line">        for (String platform : platformList) &#123;</span><br><span class="line">            System.out.println(platform);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码以上代码的输出结果为：</p>
<p><pre><br>博客园<br>个人博客<br>掘金<br>微信公众号<br></pre><br>可以看出，虽然我们尝试添加了重复元素，但并没有添加成功并且输出的元素没有顺序。<br>因此当你的集合中不允许有重复元素并且对排序也没有要求的话，可以使用Set集合。<br><a href="##">关于Set集合的详细用法，HashSet、LinkedHashSet、TreeSet的区别（这里是重点，面试可能问的比较多），后续会单独写文总结，敬请期待。</a></p>
<p>##6. Map集合<br>Map集合包括Map接口以及Map接口的所有实现类。<br>Map集合具有以下特点：</p>
<p><li>Map接口并没有继承Collection接口，提供的是key到value的映射</li></p>
<p><li>Map中不能包含相同的key</li></p>
<p><li>Map接口常用的实现类有：HashMap、HashTable、TreeMap。</li></p>
<p>我们先看下如下示例了解下Map集合的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package collection;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Muster &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;Integer, String&gt; platformMap = new HashMap&lt;&gt;();</span><br><span class="line">        platformMap.put(1, &quot;博客园&quot;);</span><br><span class="line">        platformMap.put(2, &quot;掘金&quot;);</span><br><span class="line">        platformMap.put(3, &quot;微信公众号&quot;);</span><br><span class="line">        platformMap.put(4, &quot;个人博客&quot;);</span><br><span class="line"></span><br><span class="line">        // 尝试添加重复Map</span><br><span class="line">        platformMap.put(4, &quot;个人博客&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取所有的key</span><br><span class="line">        Set&lt;Integer&gt; keys = platformMap.keySet();</span><br><span class="line">        for (Integer integer : keys) &#123;</span><br><span class="line">            System.out.println(&quot;Key:&quot; + integer + &quot;,Value:&quot; + platformMap.get(integer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制代码以上代码的输出结果为：</p>
<p><li>Key:1,Value:博客园</li></p>
<p><li>Key:2,Value:掘金</li></p>
<p><li>Key:3,Value:微信公众号</li></p>
<p><li>Key:4,Value:个人博客</li></p>
<p><li>从日志可以看出，当我们尝试重加重复Map时，并没有添加成功。</li></p>
<p><li><a href="##">关于Map集合的详细用法，HashMap、HashTable、TreeMap的区别（这里是重点，面试可能问的比较多），后续会单独写文总结，敬请期待。</a></li></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2019/08/18/一次生产问题的排查解决/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/18/一次生产问题的排查解决/" itemprop="url">JAVA线上问题的解决思路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T00:00:00+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><b>导读</b><br>java线上问题一直是个老大难的问题,紧急,信息量少,故障种类多,不易排查.那么在第一次遇到线上问题的时候我们可能会没有办法,但是随着解决问题的次数增多,对于很多线上问题,就会有了现象-分析-判定-解决这样的思路.开发人员在面对这样的问题时,一则是要见得多,从别人的博客中去分析提炼为什么会出现这样的,而不仅仅只满足答案. 二则是要能举一反三,<br>理解了病症,病灶,病因,才能药到病除.</p>
<hr>
<ul><br><li>病症</li><br><li>病灶</li><br><li>诊断</li><br><li>分析</li><br><li>对症下药</li><br></ul>

<hr>
<p></p><p>病症</p><br>典型的性能问题如页面响应慢、接口超时，服务器负载高、并发数低，数据库频繁死锁等。<p></p>
<p></p><p>病灶</p><br>Java 应用性能的瓶颈点非常多，比如磁盘、内存、网络 I/O 等系统因素，Java 应用代码，JVM GC，数据库，缓存等。<br>Java 性能优化分为 4 个层级：应用层、数据库层、框架层、JVM 层<p></p>
<p></p><p>诊断</p><br><b>OS层面的诊断</b><p></p><br>OS 的诊断主要关注的是 CPU、Memory、I/O 三个方面。<br><br>对于 CPU 主要关注平均负载（Load Average），CPU 使用率，上下文切换次数（Context Switch）。<br><br>通过 top 命令可以查看系统平均负载和 CPU 使用率<br><br>通过 vmstat 命令可以查看 CPU 的上下文切换次数<br><p></p>
<p>Memory<br><br>从操作系统角度，内存关注应用进程是否足够，可以使用 free –m 命令查看内存的使用情况<br></p>
<p>IO<br><br>通过 iostat 可以查看磁盘的读写情况，通过 CPU 的 I/O wait 可以看出磁盘 I/O 是否正常。<br></p>
<p><b>JVM层面的诊断</b><br><br>jstack,JProfiler, jstat, jmap,MAT,</p>
<p></p><p>对症下药</p><br>GC 调优目标基本有三个思路：降低 GC 频率，可以通过增大堆空间，减少不必要对象生成；降低 GC 暂停时间，可以通过减少堆空间，使用 CMS GC 算法实现；避免 Full GC，调整 CMS 触发比例，避免 Promotion Failure 和 Concurrent mode failure（老年代分配更多空间，增加 GC 线程数加快回收速度），减少大对象生成等。<p></p>
<p><b>业务逻辑层面的诊断</b></p>
<p>并发业务,不要使用静态共享全局集合来操作Hashmap是线程不安全的,多线程put操作会导致存储的链表出现死循环</p>
<p></p><h5>1、业务日志相关 </h5><br>如果系统出现异常或者业务有异常，首先想到的都是查看业务日志<p></p>
<p></p><h4>查看日志工具：<p></p>
<p></p><h6>less 或者more<p></p>
<p></p><h6>grep<p></p>
<p></p><h6>tail -f filename 查看实时的最新内容<p></p>
<p></p><h6>ps:切忌vim直接打开大日志文件，因为会直接加载到内存的<p></p>
<p></p><h5>2、数据库相关</h5><br>java应用很多瓶颈在数据库，一条sql没写好导致慢查询，可能就会带来应用带来致命危害。<br>如果出现Could not get JDBC Connection 、接口响应慢、线程打满等，<br>需要登录线上库，查看数据库连接情况：show processh6st，<br>查看当前数据库的连接情况，确实由于慢查询造成，需要手动kill<p></p>
<p></p><h5>3、JVM相关</h5><br>java虚拟机相关的问题一般多是以下几种问题：gc时间过长、OOM、死锁、线程block、线程数暴涨等问题。一般通过以下几个工具都能定位出问题。<p></p>
<p></p><h6>jps命令 </h6><br>作用<br>是显示当前用户,当前系统的java进程情况，及其id号<br>常用命令<br>-m/-l/-v 查看运行参数<p></p>
<p></p><h6>jstat命令 </h6><br>显示进程中的类装载、内存、垃圾收集、JIT编译等运行数据。<br>常用指令<br>jstat -gc 3331 250 20 ：查询进程2764的垃圾收集情况，每250毫秒查询一次，一共查询20次。<br>jstat -gccause：额外输出上次GC原因<br>jstat -calss：件事类装载、类卸载、总空间以及所消耗的时间<p></p>
<p></p><h6>jstack命令</h6><br>功能<br>生成当前时刻的线程快照。<br>常用指令<br>jstack 3331：查看线程情况<br>jstack -F 3331：正常输出不被响应时，使用该指令<br>jstack -l 3331：除堆栈外，显示关于锁的附件信息<p></p>
<p></p><h6>jmap命令</h6><br>功能<br>生成堆转储快照（heapdump）<br>常用指令<br>jmap -heap 3331：查看java 堆（heap）使用情况<br>jmap -histo 3331：查看堆内存(histogram)中的对象数量及大小<br>jmap -histo:h6ve 3331：JVM会先触发gc，然后再统计信息<br>jmap -dump:format=b,file=heapDump 3331：将内存使用的详细情况输出到文件，之后一般使用其他工具进行分析。<p></p>
<p></p><h6>jhat命令 略</h6><p></p>
<p></p><h6>3.1 OOM问题或者频繁GC问题</h6><br>发生OOM问题一般服务都会crash，业务日志会有OutOfMemoryError。OOM一般都是出现了内存泄露，需要查看OOM时候的jvm堆的快照，如果配置了-XX:+HeapDumpOnOutOfMemoryError, 在发生OOM的时候会在-XX:HeapDumpPath生成堆的dump文件，结合MAT，可以对dump文件进行分析，查找出发生OOM的原因. 关于MAT使用不详述了，google上一堆（<a href="http://inter12.iteye.com/blog/1407492）。" target="_blank" rel="noopener">http://inter12.iteye.com/blog/1407492）。</a><br>ps.<br>1、服务器的内存一般较大，所以要保证服务器的磁盘空间大于内存大小<br>2、另外手动dump堆快照，可以使用命令jmap -dump:format=b,file=file_name pid<p></p>
<p></p><h6>3.2 死锁</h6><br>死锁原因是两个或者多个线程相互等待资源，现象一般是出现线程hung住，更严重会出现线程数暴涨，系统出现api ah6ve报警等。<br>查看死锁最好的方法就是分析当时的线程栈。<br>具体case 可以参考jstack命令里面的例子<br>用到的命令：<br>jps -v<br>jstack -l pid<p></p>
<p></p><h6>3.3 线程block、线程数暴涨 </h6><br>jstack -l pid |wc -l<br>jstack -l pid |grep “BLOCKED”|wc -l<br>jstack -l pid |grep “Waiting on condition”|wc -l<p></p>
<p>线程block问题一般是等待io、等待网络、等待监视器锁等造成，可能会导致请求超时、造成造成线程数暴涨导致系统502等。<br><br>如果出现这种问题，主要是关注jstack 出来的BLOCKED、Waiting on condition、Waiting on monitor entry等状态信息。<br><br>如果大量线程在“waiting for monitor entry”：<br>可能是一个全局锁阻塞住了大量线程。<br><br>如果短时间内打印的 thread dump 文件反映，随着时间流逝，waiting for monitor entry 的线程越来越多，没有减少的趋势，可能意味着某些线程在临界区里呆的时间太长了，以至于越来越多新线程迟迟无法进入临界区。<br><br>如果大量线程在“waiting on condition”：<br>可能是它们又跑去获取第三方资源，迟迟获取不到Response，导致大量线程进入等待状态。<br>所以如果你发现有大量的线程都处在 Wait on condition，从线程堆栈看，正等待网络读写，这可能是一个网络瓶颈的征兆，因为网络阻塞导致线程无法执行。</p>
<p></p><h6>3.4 gc时间过长</h6><br>先贴一个文章占坑：&lt;a href= <a href="http://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html&gt;传送门" target="_blank" rel="noopener">http://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html&gt;传送门</a><p></p>
<p><b>4、服务器问题</b></p>
<p></p><h6>4.1 CPU</h6><br>top命令(参考<a href="https://h6nux.cn/article-2352-1.html" target="_blank" rel="noopener">https://h6nux.cn/article-2352-1.html</a>)<br>主要关注cpu的load，以及比较耗cpu的进程<br>由于现在服务器都是虚拟机，还要关注st（st 的全称是 Steal Time ，是分配给运行在其它虚拟机上的任务的实际 CPU 时间）<br>常用交互命令：<br>h 帮助，十分有用<br>R: 反向排序<br>x：将排序字段高亮显示（纵列）<br>y 将运行进程高亮显示（横行）<br>shift+&gt; 或shift+&lt;:切换排序字段<br>d或s: 设置显示的刷新间隔<br>f: 字段管理 设置显示的字段<br>k:kill进程<p></p>
<p></p><h6>4.2 内存</h6><br>free命令：<br>free -m -c10 -s1<br>-m：以MB为单位显示，其他的有-k -g -b<br>-s: 间隔多少秒持续观察内存使用状况<br>-c:观察多少次<br>vmstat命令：(<a href="http://man.h6nuxde.net/vmstat" target="_blank" rel="noopener">http://man.h6nuxde.net/vmstat</a>)<br>vmstat 1 10<br>1表示每隔1s输出一次,10 表示输出10次<br>两个参数需要关注<br>r: 运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1）<br>b: 等待IO的进程数量。<p></p>
<p></p><h6>4.3 IO</h6><br>iostat 命令（<a href="http://www.orczhou.com/index.php/2010/03/iostat-detail/）" target="_blank" rel="noopener">http://www.orczhou.com/index.php/2010/03/iostat-detail/）</a><br>iostat -m 1 10<br>-m：某些使用block为单位的列强制使用MB为单位<br>1 10：数据显示每隔1秒刷新一次，共显示10次<p></p>
<p></p><h6>4.4 网络</h6><br>netstat 命令（<a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html）" target="_blank" rel="noopener">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html）</a><br>netstat -antp <p></p>
<p>-a (all)显示所有选项，默认不显示h6STEN相关<br>-t (tcp)仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化成数字。<br>-l 仅列出有在 h6sten (监听) 的服服务状态<br>-p 显示建立相关链接的程序名</p>
<p>显示tcp各个状态数量：<br> netstat -ant |awk ‘{print $6}’|sort|uniq -c</p>
<p>查看连接某服务端口最多的的IP地址<br>netstat -nat | grep “10.32.45.35:8924” |awk ‘{print $5}’|awk -F: ‘{print $4}’|sort|uniq -c|sort -nr|head -10</p>
</h6></h6></h6></h6></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2019/03/20/JUC-线程池原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/20/JUC-线程池原理/" itemprop="url">JUC系列-线程池原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-20T00:00:00+08:00">
                2019-03-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h3>ThreadPoolExecutor使用介绍</h3><p></p>
<pre><code>
private static ExecutorService exec = new ThreadPoolExecutor(8, 8, 0L,
TimeUnit.MILLISECONDS, new LinkedBlockingQueue<runnable>(100000),
new ThreadPoolExecutor.CallerRunsPolicy());
</runnable></code></pre>

<h3>一、简介</h3><br><pre><code><br>线程池类为 java.util.concurrent.ThreadPoolExecutor，常用构造方法为：<br>ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,<br>long keepAliveTime, TimeUnit unit,<br>BlockingQueue<runnable> workQueue,<br>RejectedExecutionHandler handler)<br><br>corePoolSize： 线程池维护线程的最少数量<br>maximumPoolSize：线程池维护线程的最大数量<br>keepAliveTime： 线程池维护线程所允许的空闲时间<br>unit： 线程池维护线程所允许的空闲时间的单位<br>workQueue： 线程池所使用的缓冲队列<br>handler： 线程池对拒绝任务的处理策略<br></runnable></code></pre><br><br><br>一个任务通过 execute(Runnable)方法被添加到线程池，任务就是一个 Runnable类型的对象，任务的执行方法就是Runnable类型对象的run()方法。<br><br><br><h3>二、原理</h3><br>当一个任务通过execute(Runnable)方法欲添加到线程池时:<br>1.  如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。<br>2.  如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。<br>3.  如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。<br>4.  如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。<br>5. 当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。<br>6. unit可选的参数为java.util.concurrent.TimeUnit中的几个静态属性：<br>NANOSECONDS、<br>MICROSECONDS、<br>MILLISECONDS、<br>SECONDS。<br><br>7. workQueue常用的是：java.util.concurrent.ArrayBlockingQueue<br>8. handler有四个选择：<br><pre><code><br>  1. ThreadPoolExecutor.AbortPolicy()<br>抛出java.util.concurrent.RejectedExecutionException异常<br><br>  2. ThreadPoolExecutor.CallerRunsPolicy()<br>当抛出RejectedExecutionException异常时，会调用rejectedExecution方法<br>(如果主线程没有关闭，则主线程调用run方法,源码如下:<br>public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {<br>            if (!e.isShutdown()) {<br>                r.run();<br>            }<br>        }<br><br>)<br><br>  3. ThreadPoolExecutor.DiscardOldestPolicy()<br>抛弃旧的任务<br>  4. ThreadPoolExecutor.DiscardPolicy()<br>抛弃当前的任务<br></code></pre><br><br><h3>三、相关参考</h3><br>一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。<br><br>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行集合任务时使用的线程）的方法。每个ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。<br><br>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展挂钩。但是，强烈建议程序员使用较为方便的 Executors 工厂方法 Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、Executors.newFixedThreadPool(int)（固定大小线程池）和 Executors.newSingleThreadExecutor()（单个后台线程），它们均为大多数使用场景预定义了设置。否则，在手动配置和调整此类时，使用以下指导：<br><h4>核心和最大池大小</h4><br>ThreadPoolExecutor 将根据 corePoolSize（参见 getCorePoolSize()）和 maximumPoolSize（参见getMaximumPoolSize()）设置的边界自动调整池大小。<br>当新任务在方法 execute(java.lang.Runnable) 中提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。<br><br>如果运行的线程多于corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程。如果设置的 corePoolSize 和 maximumPoolSize相同，则创建了固定大小的线程池。<br>如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。在大多数情况下，核心和最大池大小仅基于构造来设置，不过也可以使用setCorePoolSize(int) 和 setMaximumPoolSize(int) 进行动态更改。<br><br><br><br><h4>按需构造</h4><br>默认情况下，即使核心线程最初只是在新任务需要时才创建和启动的，也可以使用方法 prestartCoreThread()或 prestartAllCoreThreads() 对其进行动态重写。<br><br><h4>创建新线程</h4><br>使用 ThreadFactory 创建新线程。如果没有另外说明，则在同一个 ThreadGroup 中一律使用Executors.defaultThreadFactory() 创建线程，并且这些线程具有相同的 NORM_PRIORITY 优先级和非守护进程状态。通过提供不同的 ThreadFactory，可以改变线程的名称、线程组、优先级、守护进程状态，等等。如果从 newThread返回 null 时 ThreadFactory 未能创建线程，则执行程序将继续运行，但不能执行任何任务。<br><br><h4>保持活动时间</h4><br>如果池中当前有多于 corePoolSize 的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止（参见getKeepAliveTime(java.util.concurrent.TimeUnit)）。这提供了当池处于非活动状态时减少资源消耗的方法。如果池后来变得更为活动，则可以创建新的线程。也可以使用方法 setKeepAliveTime(long, java.util.concurrent.TimeUnit) 动态地更改此参数。使用 Long.MAX_VALUE TimeUnit.NANOSECONDS 的值在关闭前有效地从以前的终止状态禁用空闲线程。<br><br><h4>排队</h4><br>所有 BlockingQueue 都可用于传输和保持提交的任务。可以使用此队列与池大小进行交互：<br>1. 如果运行的线程少于 corePoolSize，则 Executor 始终首选添加新的线程，而不进行排队。<br>2. 如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。<br>3.如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。<br><br><h4>排队有三种通用策略：</h4><br>1. 直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集合时出现锁定。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。<br><br>2. 无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙的情况下将新任务加入队列。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。<br><br>3. 有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。<br><br><h4>被拒绝的任务</h4><br>当 Executor 已经关闭，并且 Executor 将有限边界用于最大线程和工作队列容量，且已经饱和时，在方法execute(java.lang.Runnable) 中提交的新任务将被拒绝。在以上两种情况下，execute 方法都将调用其RejectedExecutionHandler 的 RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor) 方法。<br>下面提供了四种预定义的处理程序策略:<br>1.在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时 RejectedExecutionException。<br>2.在 ThreadPoolExecutor.CallerRunsPolicy 中，线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。<br>3.在 ThreadPoolExecutor.DiscardPolicy 中，不能执行的任务将被删除。<br>4.在 ThreadPoolExecutor.DiscardOldestPolicy 中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。<br>5. 定义和使用其他种类的 RejectedExecutionHandler 类也是可能的，但这样做需要非常小心，尤其是当策略仅用于特定容量或排队策略时。<br><br><h4>挂钩方法</h4><br>此类提供 protected 可重写的 beforeExecute(java.lang.Thread, java.lang.Runnable) 和 afterExecute(java.lang.Runnable, java.lang.Throwable) 方法，这两种方法分别在执行每个任务之前和之后调用。它们可用于操纵执行环境；例如，重新初始化ThreadLocal、搜集统计信息或添加日志条目。此外，还可以重写方法 terminated() 来执行 Executor 完全终止后需要完成的所有特殊处理。<br><br><br>如果挂钩或回调方法抛出异常，则内部辅助线程将依次失败并突然终止。<br><br><br><h4>队列维护</h4><br><p>方法 getQueue() 允许出于监控和调试目的而访问工作队列。强烈反对出于其他任何目的而使用此方法。remove(java.lang.Runnable) 和 purge() 这两种方法可用于在取消大量已排队任务时帮助进行存储回收。<br></p><br>一、例子<br>创建 TestThreadPool 类<br><br><pre><br><code><br><br>import java.util.concurrent.ArrayBlockingQueue;<br>import java.util.concurrent.ThreadPoolExecutor;<br>import java.util.concurrent.TimeUnit;<br><br>public class TestThreadPool {<br><br>    private static int produceTaskSleepTime = 2;<br><br>    private static int produceTaskMaxNumber = 10;<br><br>    public static void main(String[] args) {<br><br>        // 构造一个线程池<br>        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 4, 3,<br>                TimeUnit.SECONDS, new ArrayBlockingQueue<runnable>(3),<br>                new ThreadPoolExecutor.DiscardOldestPolicy());<br><br>        for (int i = 1; i &lt;= produceTaskMaxNumber; i++) {<br>            try {<br>                String task = “task@ “ + i;<br>                System.out.println(“创建任务并提交到线程池中：” + task);<br>                threadPool.execute(new ThreadPoolTask(task));<br><br>                Thread.sleep(produceTaskSleepTime);<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>            }<br>        }<br>    }<br>}<br><br>import java.io.Serializable;<br><br>public class ThreadPoolTask implements Runnable, Serializable {<br><br>    private Object attachData;<br><br>    ThreadPoolTask(Object tasks) {<br>        this.attachData = tasks;<br>    }<br><br>    public void run() {<br><br>        System.out.println(“开始执行任务：” + attachData);<br><br>        attachData = null;<br>    }<br><br>    public Object getTask() {<br>        return this.attachData;<br>    }<br>}<br><br><br><br>执行结果：<br><br>创建任务并提交到线程池中：task@ 1<br><br>开始执行任务：task@ 1<br><br>创建任务并提交到线程池中：task@ 2<br><br>开始执行任务：task@ 2<br><br>创建任务并提交到线程池中：task@ 3<br><br>创建任务并提交到线程池中：task@ 4<br><br>开始执行任务：task@ 3<br><br>创建任务并提交到线程池中：task@ 5<br><br>开始执行任务：task@ 4<br><br>创建任务并提交到线程池中：task@ 6<br><br>创建任务并提交到线程池中：task@ 7<br><br>创建任务并提交到线程池中：task@ 8<br><br>开始执行任务：task@ 5<br><br>开始执行任务：task@ 6<br><br>创建任务并提交到线程池中：task@ 9<br><br>开始执行任务：task@ 7<br><br>创建任务并提交到线程池中：task@ 10<br><br>开始执行任务：task@ 8<br><br>开始执行任务：task@ 9<br><br>开始执行任务：task@ 10<br></runnable></code><br></pre><br><br><br><h3>四.ThreadPoolExecutor配置</h3>

<ol>
<li><p>ThreadPoolExcutor为一些Executor提供了基本的实现，这些Executor是由Executors中的工厂 newCahceThreadPool、newFixedThreadPool和newScheduledThreadExecutor返回的。 ThreadPoolExecutor是一个灵活的健壮的池实现，允许各种各样的用户定制。</p>
</li>
<li><p>线程的创建与销毁</p>
<ol>
<li>核心池大小、最大池大小和存活时间共同管理着线程的创建与销毁。</li>
<li>核心池的大小是目标的大小；线程池的实现试图维护池的大小；即使没有任务执行，池的大小也等于核心池的大小，并直到工作队列充满前，池都不会创建更多的线程。如果当前池的大小超过了核心池的大小，线程池就会终止它。</li>
</ol>
</li>
<li><p>最大池的大小是可同时活动的线程数的上限。</p>
</li>
<li>如果一个线程已经闲置的时间超过了存活时间，它将成为一个被回收的候选者。</li>
<li>newFixedThreadPool工厂为请求的池设置了核心池的大小和最大池的大小，而且池永远不会超时</li>
<li>newCacheThreadPool工厂将最大池的大小设置为Integer.MAX_VALUE，核心池的大小设置为0，超时设置为一分钟。这样创建了无限扩大的线程池，会在需求量减少的情况下减少线程数量。</li>
</ol>
<h3> 五.管理</h3>

<ol>
<li>ThreadPoolExecutor允许你提供一个BlockingQueue来持有等待执行的任务。任务排队有3种基本方法：无限队列、有限队列和同步移交。</li>
<li>newFixedThreadPool和newSingleThreadExectuor默认使用的是一个无限的 LinkedBlockingQueue。如果所有的工作者线程都处于忙碌状态，任务会在队列中等候。如果任务持续快速到达，超过了它们被执行的速度，队列也会无限制地增加。稳妥的策略是使用有限队列，比如ArrayBlockingQueue或有限的LinkedBlockingQueue以及 PriorityBlockingQueue。</li>
<li>对于庞大或无限的池，可以使用SynchronousQueue，完全绕开队列，直接将任务由生产者交给工作者线程</li>
<li>可以使用PriorityBlockingQueue通过优先级安排任务</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2019/03/10/JUC-Java实现生产者消费者模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/10/JUC-Java实现生产者消费者模型/" itemprop="url">JUC系列-Java实现生产者消费者模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-10T00:00:00+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>JUC系列-Java实现生产者-消费者模型</h3><br>有如下考点:<br><br>1.对java并发模型的理解<br><br>2.对并发编程接口的熟练程度<br><br><code>jdk: oracle java 1.8.0_102</code><br><br>本文主要归纳了3种写法，阅读后，最好在白板上练习几遍，检查自己是否掌握。这4种写法或者编程接口不同，或者并发粒度不同，但本质是相同的——都是在使用或实现BlockingQueue。<br><br><h3>生产者-消费者模型</h3><br>网上有很多生产者-消费者模型的定义和实现。本文研究最常用的有界生产者-消费者模型，简单概括如下：<br><ol><br><li>生产者持续生产，直到缓冲区满，阻塞；缓冲区不满后，继续生产</li><br><li>消费者持续消费，直到缓冲区空，阻塞；缓冲区不空后，继续消费</li><br><li>生产者可以有多个，消费者也可以有多个</li><br><br>可通过如下条件验证模型实现的正确性：<br><li>同一产品的消费行为一定发生在生产行为之后</li><br><li>任意时刻，缓冲区大小不小于0，不大于限制容量</li><br><li>该模型的应用和变种非常多，不赘述。</li><br></ol><br><br><h4>准备</h4><br>关键部分需要实现,抽象，如AbstractConsumer。<br><br><br>下面会涉及多种生产者-消费者模型的实现，可以先抽象出关键的接口，并实现一些抽象类<br><pre><br><br>public interface Consumer {<br>  void consume() throws InterruptedException;<br>}<br><br><br>public interface Producer {<br>  void produce() throws InterruptedException;<br>}<br><br>abstract class AbstractConsumer implements Consumer, Runnable {<br>  @Override<br>  public void run() {<br>    while (true) {<br>      try {<br>        consume();<br>      } catch (InterruptedException e) {<br>        e.printStackTrace();<br>        break;<br>      }<br>    }<br>  }<br>}<br><br>abstract class AbstractProducer implements Producer, Runnable {<br>  @Override<br>  public void run() {<br>    while (true) {<br>      try {<br>        produce();<br>      } catch (InterruptedException e) {<br>        e.printStackTrace();<br>        break;<br>      }<br>    }<br>  }<br>}<br><br></pre><br><br>不同的模型实现中，生产者、消费者的具体实现也不同，所以需要为模型定义抽象工厂方法：<br><br><pre><br><br>public interface Model {<br>  Runnable newRunnableConsumer();<br>  Runnable newRunnableProducer();<br>}<br><br>我们将Task作为生产和消费的单位<br>public class Task {<br>  public int no;<br>  public Task(int no) {<br>    this.no = no;<br>  }<br>}<br><br></pre><br><br>如果需求还不明确（这符合大部分工程工作的实际情况），建议边实现边抽象，不要“面向未来编程”。<br><br><h3>实现一：BlockingQueue</h3>

<p>BlockingQueue的写法最简单。核心思想是，把并发和容量控制封装在缓冲区中。而BlockingQueue的性质天生满足这个要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class BlockingQueueModel implements Model &#123;</span><br><span class="line">  private final BlockingQueue&lt;Task&gt; queue;</span><br><span class="line">  private final AtomicInteger increTaskNo = new AtomicInteger(0);</span><br><span class="line">  public BlockingQueueModel(int cap) &#123;</span><br><span class="line">    // LinkedBlockingQueue 的队列不 init，入队时检查容量；ArrayBlockingQueue 在创建时 init</span><br><span class="line">    this.queue = new LinkedBlockingQueue&lt;&gt;(cap);</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Runnable newRunnableConsumer() &#123;</span><br><span class="line">    return new ConsumerImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Runnable newRunnableProducer() &#123;</span><br><span class="line">    return new ProducerImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  private class ConsumerImpl extends AbstractConsumer implements Consumer, Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void consume() throws InterruptedException &#123;</span><br><span class="line">      Task task = queue.take();</span><br><span class="line">      // 固定时间范围的消费，模拟相对稳定的服务器处理过程</span><br><span class="line">      Thread.sleep(500 + (long) (Math.random() * 500));</span><br><span class="line">      System.out.println(&quot;consume: &quot; + task.no);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private class ProducerImpl extends AbstractProducer implements Producer, Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() throws InterruptedException &#123;</span><br><span class="line">      // 不定期生产，模拟随机的用户请求</span><br><span class="line">      Thread.sleep((long) (Math.random() * 1000));</span><br><span class="line">      Task task = new Task(increTaskNo.getAndIncrement());</span><br><span class="line">      System.out.println(&quot;produce: &quot; + task.no);</span><br><span class="line">      queue.put(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Model model = new BlockingQueueModel(3);</span><br><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">      new Thread(model.newRunnableConsumer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">      new Thread(model.newRunnableProducer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">截取前面的一部分输出：</span><br><span class="line">produce: 0</span><br><span class="line">produce: 4</span><br><span class="line">produce: 2</span><br><span class="line">produce: 3</span><br><span class="line">produce: 5</span><br><span class="line">consume: 0</span><br><span class="line">produce: 1</span><br><span class="line">consume: 4</span><br><span class="line">produce: 7</span><br><span class="line">consume: 2</span><br><span class="line">produce: 8</span><br><span class="line">consume: 3</span><br><span class="line">produce: 6</span><br><span class="line">consume: 5</span><br><span class="line">produce: 9</span><br><span class="line">consume: 1</span><br><span class="line">produce: 10</span><br><span class="line">consume: 7</span><br></pre></td></tr></table></figure>
<p></p><h4>验证条件</h4><br>由于操作“出队/入队+日志输出”不是原子的，所以上述日志的绝对顺序与实际的出队/入队顺序有出入，但对于同一个任务号task.no，其consume日志一定出现在其produce日志之后，即：同一任务的消费行为一定发生在生产行为之后。缓冲区的容量留给读者验证。符合两个验证条件。<p></p>
<p>BlockingQueue写法的核心只有两行代码，并发和容量控制都封装在了BlockingQueue中，正确性由BlockingQueue保证。</p>
<p></p><h3>实现二：wait &amp;&amp; notify</h3><br>如果不能将并发与容量控制都封装在缓冲区中，就只能由消费者与生产者完成。最简单的方案是使用朴素的<code>wait &amp;&amp; notify</code>机制。<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class WaitNotifyModel implements Model &#123;</span><br><span class="line">  private final Object BUFFER_LOCK = new Object();</span><br><span class="line">  private final Queue&lt;Task&gt; buffer = new LinkedList&lt;&gt;();</span><br><span class="line">  private final int cap;</span><br><span class="line">  private final AtomicInteger increTaskNo = new AtomicInteger(0);</span><br><span class="line">  public WaitNotifyModel(int cap) &#123;</span><br><span class="line">    this.cap = cap;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Runnable newRunnableConsumer() &#123;</span><br><span class="line">    return new ConsumerImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Runnable newRunnableProducer() &#123;</span><br><span class="line">    return new ProducerImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  private class ConsumerImpl extends AbstractConsumer implements Consumer, Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void consume() throws InterruptedException &#123;</span><br><span class="line">      synchronized (BUFFER_LOCK) &#123;</span><br><span class="line">        while (buffer.size() == 0) &#123;</span><br><span class="line">          BUFFER_LOCK.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        Task task = buffer.poll();</span><br><span class="line">        assert task != null;</span><br><span class="line">        // 固定时间范围的消费，模拟相对稳定的服务器处理过程</span><br><span class="line">        Thread.sleep(500 + (long) (Math.random() * 500));</span><br><span class="line">        System.out.println(&quot;consume: &quot; + task.no);</span><br><span class="line">        BUFFER_LOCK.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private class ProducerImpl extends AbstractProducer implements Producer, Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() throws InterruptedException &#123;</span><br><span class="line">      // 不定期生产，模拟随机的用户请求</span><br><span class="line">      Thread.sleep((long) (Math.random() * 1000));</span><br><span class="line">      synchronized (BUFFER_LOCK) &#123;</span><br><span class="line">        while (buffer.size() == cap) &#123;</span><br><span class="line">          BUFFER_LOCK.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        Task task = new Task(increTaskNo.getAndIncrement());</span><br><span class="line">        buffer.offer(task);</span><br><span class="line">        System.out.println(&quot;produce: &quot; + task.no);</span><br><span class="line">        BUFFER_LOCK.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Model model = new WaitNotifyModel(3);</span><br><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">      new Thread(model.newRunnableConsumer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">      new Thread(model.newRunnableProducer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><h3>实现三：简单的Lock &amp;&amp; Condition</h3><br>我们要保证理解wait &amp;&amp; notify机制。实现时可以使用Object类提供的wait()方法与notifyAll()方法，但更推荐的方式是使用java.util.concurrent包提供的Lock &amp;&amp; Condition。<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class LockConditionModel1 implements Model &#123;</span><br><span class="line">  private final Lock BUFFER_LOCK = new ReentrantLock();</span><br><span class="line">  private final Condition BUFFER_COND = BUFFER_LOCK.newCondition();</span><br><span class="line">  private final Queue&lt;Task&gt; buffer = new LinkedList&lt;&gt;();</span><br><span class="line">  private final int cap;</span><br><span class="line">  private final AtomicInteger increTaskNo = new AtomicInteger(0);</span><br><span class="line">  public LockConditionModel1(int cap) &#123;</span><br><span class="line">    this.cap = cap;</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Runnable newRunnableConsumer() &#123;</span><br><span class="line">    return new ConsumerImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public Runnable newRunnableProducer() &#123;</span><br><span class="line">    return new ProducerImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  private class ConsumerImpl extends AbstractConsumer implements Consumer, Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void consume() throws InterruptedException &#123;</span><br><span class="line">      BUFFER_LOCK.lockInterruptibly();</span><br><span class="line">      try &#123;</span><br><span class="line">        while (buffer.size() == 0) &#123;</span><br><span class="line">          BUFFER_COND.await();</span><br><span class="line">        &#125;</span><br><span class="line">        Task task = buffer.poll();</span><br><span class="line">        assert task != null;</span><br><span class="line">        // 固定时间范围的消费，模拟相对稳定的服务器处理过程</span><br><span class="line">        Thread.sleep(500 + (long) (Math.random() * 500));</span><br><span class="line">        System.out.println(&quot;consume: &quot; + task.no);</span><br><span class="line">        BUFFER_COND.signalAll();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        BUFFER_LOCK.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  private class ProducerImpl extends AbstractProducer implements Producer, Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() throws InterruptedException &#123;</span><br><span class="line">      // 不定期生产，模拟随机的用户请求</span><br><span class="line">      Thread.sleep((long) (Math.random() * 1000));</span><br><span class="line">      BUFFER_LOCK.lockInterruptibly();</span><br><span class="line">      try &#123;</span><br><span class="line">        while (buffer.size() == cap) &#123;</span><br><span class="line">          BUFFER_COND.await();</span><br><span class="line">        &#125;</span><br><span class="line">        Task task = new Task(increTaskNo.getAndIncrement());</span><br><span class="line">        buffer.offer(task);</span><br><span class="line">        System.out.println(&quot;produce: &quot; + task.no);</span><br><span class="line">        BUFFER_COND.signalAll();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        BUFFER_LOCK.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Model model = new LockConditionModel1(3);</span><br><span class="line">    for (int i = 0; i &lt; 2; i++) &#123;</span><br><span class="line">      new Thread(model.newRunnableConsumer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">      new Thread(model.newRunnableProducer()).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该写法的思路与实现二的思路完全相同，仅仅将锁与条件变量换成了Lock和Condition。</p>
<p></p><h3>总结</h3><br>方法1最简单,线程的并发同步和容量控制全部交给了LinkedBlockingQueue实现,自然美观,封装了复杂度.<p></p>
<p>方法2和方法3是相同的原理,使用了手动控制并发同步,锁和竞争条件的运用.这对于我深入到阻塞队列实现的阻塞原理有了更加客观的认识.</p>
<p>如果还有其他的实现方式,欢迎补充探讨,再次感谢阅读并指正.</p>
<hr>
<pre>
author:shengfq
qq:1085748383
email: 1085748383@qq.com
date:2019-03-10
</pre>

<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2018/11/19/JUC-ArrayBlockingQueue源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/19/JUC-ArrayBlockingQueue源码分析/" itemprop="url">JUC多线程系列-ArrayBlockingQueue源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-19T00:00:00+08:00">
                2018-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2>JUC多线程系列-ArrayBlockingQueue源码分析</h2><br><h3>背景</h3><br>最近在项目中应用到后台异步任务并发应用,干脆系统的撸一遍JUC,然后应用到项目中实战.<br><br><p>使用阻塞队列实现生产者消费者模式</p><br>优点:阻塞队列实现生产者消费者模式超级简单，它提供开箱即用支持阻塞的方法put()和take()，开发者不需要写困惑的wait-nofity代码去实现通信。BlockingQueue 一个接口，Java5提供了不同的现实，如ArrayBlockingQueue和LinkedBlockingQueue，两者都是先进先出（FIFO）顺序。而ArrayLinkedQueue是自然有界的，LinkedBlockingQueue可选的边界。下面这是一个完整的生产者消费者代码例子，对比传统的wait、nofity代码，它更易于理解。<br><br><br><h3>目录</h3><br><ol><br><li> ArrayBlockingQueue介绍</li><br><li>ArrayBlockingQueue原理和数据结构</li><br><li> ArrayBlockingQueue函数列表</li><br><li> ArrayBlockingQueue源码分析(JDK1.8版本)</li><br><li>ArrayBlockingQueue示例</li><br></ol><br><br><h2>正文</h2><br><h2>1.ArrayBlockingQueue介绍</h2><br>ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。<br>线程安全是指，ArrayBlockingQueue内部通过“互斥锁”保护竞争资源，实现了多线程对竞争资源的互斥访问。而有界，则是指ArrayBlockingQueue对应的数组是有界限的。 阻塞队列，是指多线程访问竞争资源时，当竞争资源已被某线程获取时，其它要获取该资源的线程需要阻塞等待；而且，ArrayBlockingQueue是按 FIFO（先进先出）原则对元素进行排序，元素都是从尾部插入到队列，从头部开始返回。<br><br><br><br><a>注意：ArrayBlockingQueue不同于ConcurrentLinkedQueue，ArrayBlockingQueue是数组实现的，并且是有界限的；而ConcurrentLinkedQueue是链表实现的，是无界限的。<br></a><br><br><h2>2.ArrayBlockingQueue原理和数据结构</h2><br><ol><br><li> ArrayBlockingQueue继承于AbstractQueue，并且它实现了BlockingQueue接口。</li><br><li>  ArrayBlockingQueue内部是通过Object[]数组保存数据的，也就是说ArrayBlockingQueue本质上是通过数组实现的。ArrayBlockingQueue的大小，即数组的容量是创建ArrayBlockingQueue时指定的。</li><br><li>  ArrayBlockingQueue与ReentrantLock是组合关系，ArrayBlockingQueue中包含一个ReentrantLock对象(lock)。ReentrantLock是可重入的互斥锁，ArrayBlockingQueue就是根据该互斥锁实现“多线程对竞争资源的互斥访问”。而且，ReentrantLock分为公平锁和非公平锁，关于具体使用公平锁还是非公平锁，在创建ArrayBlockingQueue时可以指定；而且，ArrayBlockingQueue默认会使用非公平锁。</li><br><li>  ArrayBlockingQueue与Condition是组合关系，ArrayBlockingQueue中包含两个Condition对象(notEmpty和notFull)。<br></li><br></ol><br><br><h2>3.ArrayBlockingQueue函数列表</h2>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> private ArrayBlockingQueue&lt;Integer&gt; queue=new ArrayBlockingQueue&lt;Integer&gt;(size);</span><br><span class="line">// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则抛出 IllegalStateException。</span><br><span class="line">    private boolean add(Integer num)&#123;</span><br><span class="line">       return queue.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">// 将指定的元素插入到此队列的尾部（如果立即可行且不会超过该队列的容量），在成功时返回 true，如果此队列已满，则返回 false。</span><br><span class="line">    private boolean offer(Integer num)&#123;</span><br><span class="line">        return queue.offer(num);</span><br><span class="line">    &#125;</span><br><span class="line">/ 创建一个带有给定的（固定）容量和默认访问策略的 ArrayBlockingQueue。</span><br><span class="line">ArrayBlockingQueue(int capacity)</span><br><span class="line">// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue。</span><br><span class="line">ArrayBlockingQueue(int capacity, boolean fair)</span><br><span class="line">// 创建一个具有给定的（固定）容量和指定访问策略的 ArrayBlockingQueue，它最初包含给定 collection 的元素，并以 collection 迭代器的遍历顺序添加元素。</span><br><span class="line">ArrayBlockingQueue(int capacity, boolean fair, Collection&lt;? extends E&gt; c)</span><br><span class="line"></span><br><span class="line">    //TODO 将指定的元素插入此队列的尾部，如果该队列已满，则等待可用的空间。</span><br><span class="line">    private void put(Integer num) throws InterruptedException &#123;</span><br><span class="line">         queue.put(num);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取但不移除此队列的头；如果此队列为空，则返回 null。</span><br><span class="line">    private Integer peek()&#123;</span><br><span class="line">       return queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">    private Integer poll()&#123;</span><br><span class="line">        return queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    //TODO 获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。</span><br><span class="line">    private Integer take() throws InterruptedException&#123;</span><br><span class="line">        return queue.take();</span><br><span class="line">    &#125;</span><br><span class="line">    // 从此队列中移除指定元素的单个实例（如果存在）</span><br><span class="line">    private boolean remove(Integer num)&#123;</span><br><span class="line">        return queue.remove(num);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回此队列中元素的数量。</span><br><span class="line">    private int getSize()&#123;</span><br><span class="line">      return queue.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p></p><h2>4.源码分析</h2><p></p>
<h3>创建</h3>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">        if (capacity &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        this.items = new Object[capacity];//存放数组</span><br><span class="line">        lock = new ReentrantLock(fair); //互斥锁</span><br><span class="line">        notEmpty = lock.newCondition();//竞争条件</span><br><span class="line">        notFull =  lock.newCondition();//竞争条件</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">添加</span><br><span class="line">   offer() //队列满了返回false</span><br><span class="line">   add() //队列满了抛出异常</span><br><span class="line">   put() //队列慢了,阻塞线程</span><br><span class="line">取出</span><br><span class="line">   poll()//获取并移除此队列的头，如果此队列为空，则返回 null。</span><br><span class="line">   remove()//获取并移除此队列的头，如果为空,返回false</span><br><span class="line">   take() //获取并移除此队列的头部，在元素变得可用之前一直等待（如果有必要）。</span><br><span class="line">遍历</span><br><span class="line">   iterator() //符合Collection 接口</span><br></pre></td></tr></table></figure>
<p></p><h2>总结</h2><br>    这些API都不需要记忆,因为编程的时候,你可以查看API的实现原理.重点是要花时间把他看懂,知道为什么实现的.<p></p>
<p>5.思考题ArrayBlockingQueue示例<br>   一个线程打印1-52,一个线程打印A-Z<br>   要求控制台输出A12B34C56….Z5152</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2018/10/23/Java 处理 XML 的三种主流技术及介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/Java 处理 XML 的三种主流技术及介绍/" itemprop="url">Java 处理 XML 的三种主流技术及介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-23T00:00:00+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###转载:顾彬, 冯晨, 和 乔彬<br>2012 年 8 月 13 日发布</p>
<p>最初，XML 语言仅仅是意图用来作为 HTML 语言的替代品而出现的，但是随着该语言的不断发展和完善，人们越来越发现它所具有的优点：例如标记语言可扩展，严格的语法规定，可使用有意义的标记，内容存储和表现分离等等优势注定了该语言从诞生之日起就会走向辉煌。 XML 语言在成为 W3C 标准之后进入到了一个快速发展的时期，当然它本身所具有的一系列优点和优势也注定了各大技术厂商对它的偏爱，Java 作为软件行业的一种开发技术也迅速作出了反应，出现了多种对 XML 支持的工具，本文将会从这个角度对 Java 处理 XML 的几种主流技术进行介绍，希望能对您有所帮助。在这篇文章中，您将会得到以下信息：</p>
<p>Java 提供了哪些优秀的类库及工具便于程序员对 XML 进行处理 ?<br>有了 DOM 了，其它工具类库还有必要么 ?<br>几个小例程带你快速了解这三种解析方式<br>Java 有哪些优秀的类库及工具便于程序员对 XML 进行处理 ?</p>
<p>大名鼎鼎的 DOM</p><br><p>绿色环保的 SAX</p><br><p>默默无闻的 Digester</p>

<p></p><h4>XML 三种解析方式简介</h4><br>大名鼎鼎的 DOM<p></p>
<p>说它大名鼎鼎可是一点不为过，DOM 是 W3C 处理 XML 的标准 API，它是许多其它与 XML 处理相关的标准的基础，不仅是 Java，其它诸如 Javascript，PHP，MS .NET 等等语言都实现了该标准， 成为了应用最为广泛的 XML 处理方式。当然，为了能提供更多更加强大的功能，Java 对于 DOM 直接扩展工具类有很多，比如很多 Java 程序员耳熟能详的 JDOM，DOM4J 等等， 它们基本上属于对 DOM 接口功能的扩充，保留了很多 DOM API 的特性，许多原本的 DOM 程序员甚至都没有任何障碍就熟练掌握了另外两者的使用，直观、易于操作的方式使它深受广大 Java 程序员的喜爱。</p>
<p>绿色环保的 SAX</p>
<p>SAX 的应运而生有它特殊的需要，为什么说它绿色环保呢，这是因为 SAX 使用了最少的系统资源和最快速的解析方式对 XML 处理提供了支持。 但随之而来繁琐的查找方式也给广大程序员带来许多困扰，常常令人头痛不已，同时它对 XPath 查询功能的支持，令人们对它又爱又恨。</p>
<p>默默无闻的 Digester：XML 的 JavaBean 化</p>
<p>Digester 是 apache 基金组织下的一个开源项目，笔者对它的了解源于对 Struts 框架的研究，是否有很多程序员想要一解各大开源框架的设计甚至想要自己写一个功能强大的框架时会碰到这样一个难题： 这些形形色色的用 XML 语言标记的框架配置文件，框架底层是用什么技术来解析呢？ DOM 解析耗费时间，SAX 解析又过于繁琐，况且每次解析系统开销也会过大， 于是，大家想到需要用与 XML 结构相对应的 JavaBean 来装载这些信息，由此 Digester 应运而生。它的出现为 XML 转换为 JavaBean 对象的需求带来了方便的操作接口，使得更多的类似需求得到了比较完美的解决方法， 不再需要程序员自己实现此类繁琐的解析程序了。与此同时 SUN 也推出了 XML 和 JavaBean 转换工具类 JAXB，有兴趣的读者可以自行了解。</p>
<p>三种解析方式比较<br><br>DOM</p>
<p>优缺点：实现 W3C 标准，有多种编程语言支持这种解析方式，并且这种方法本身操作上简单快捷，十分易于初学者掌握。其处理方式是将 XML 整个作为类似树结构的方式读入内存中以便操作及解析，因此支持应用程序对 XML 数据的内容和结构进行修改，但是同时由于其需要在处理开始时将整个 XML 文件读入到内存中去进行分析，因此其在解析大数据量的 XML 文件时会遇到类似于内存泄露以及程序崩溃的风险，请对这点多加注意。</p>
<p>适用范围：小型 XML 文件解析、需要全解析或者大部分解析 XML、需要修改 XML 树内容以生成自己的对象模型</p>
<p>SAX</p>
<p>SAX 从根本上解决了 DOM 在解析 XML 文档时产生的占用大量资源的问题。其实现是通过类似于流解析的技术，通读整个 XML 文档树，通过事件处理器来响应程序员对于 XML 数据解析的需求。由于其不需要将整个 XML 文档读入内存当中，它对系统资源的节省是十分显而易见的，它在一些需要处理大型 XML 文档以及性能要求较高的场合有起了十分重要的作用。支持 XPath 查询的 SAX 使得开发人员更加灵活，处理起 XML 来更加的得心应手。但是同时，其仍然有一些不足之处也困扰广大的开发人员：首先是它十分复杂的 API 接口令人望而生畏，其次由于其是属于类似流解析的文件扫描方式，因此不支持应用程序对于 XML 树内容结构等的修改，可能会有不便之处。</p>
<p>适用范围：大型 XML 文件解析、只需要部分解析或者只想取得部分 XML 树内容、有 XPath 查询需求、有自己生成特定 XML 树对象模型的需求</p>
<p>Digester/JAXB</p>
<p>优缺点 : 由于其是在上述两者的基础上衍生出来的工具类，为的是满足将 XML 转换为 JavaBean 的特殊需求，故而没有什么特别明显的优缺点。作为大名鼎鼎的开源框架 Struts 的 XML 解析工具 Digester，为我们带来了将 XML 转换为 JavaBean 的可靠方法。</p>
<p>适用范围 : 有将 XML 文档直接转换为 JavaBean 需求。</p>
<p>应用示例<br>下面给出一段用于解析的 XML 片段：</p>
<p>清单 1. XML 片段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;books&gt; </span><br><span class="line">  &lt;book id=&quot;001&quot;&gt; </span><br><span class="line">     &lt;title&gt;Harry Potter&lt;/title&gt; </span><br><span class="line">     &lt;author&gt;J K. Rowling&lt;/author&gt; </span><br><span class="line">  &lt;/book&gt; </span><br><span class="line">  &lt;book id=&quot;002&quot;&gt; </span><br><span class="line">     &lt;title&gt;Learning XML&lt;/title&gt; </span><br><span class="line">     &lt;author&gt;Erik T. Ray&lt;/author&gt; </span><br><span class="line">  &lt;/book&gt; </span><br><span class="line">&lt;/books&gt;</span><br></pre></td></tr></table></figure>
<p>DOM 解析 XML</p>
<p>Java 中的 DOM 接口简介： JDK 中的 DOM API 遵循 W3C DOM 规范，其中 org.w3c.dom 包提供了 Document、DocumentType、Node、NodeList、Element 等接口， 这些接口均是访问 DOM 文档所必须的。我们可以利用这些接口创建、遍历、修改 DOM 文档。</p>
<p>javax.xml.parsers 包中的 DoumentBuilder 和 DocumentBuilderFactory 用于解析 XML 文档生成对应的 DOM Document 对象。</p>
<p>javax.xml.transform.dom 和 javax.xml.transform.stream 包中 DOMSource 类和 StreamSource 类，用于将更新后的 DOM 文档写入 XML 文件。</p>
<p>下面给出一个运用 DOM 解析 XML 的例子：</p>
<p>清单 2. DOM 解析 XML</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File; </span><br><span class="line">import java.io.IOException; </span><br><span class="line">import javax.xml.parsers.DocumentBuilder; </span><br><span class="line">import javax.xml.parsers.DocumentBuilderFactory; </span><br><span class="line">import javax.xml.parsers.ParserConfigurationException; </span><br><span class="line">import org.w3c.dom.Document; </span><br><span class="line">import org.w3c.dom.Element; </span><br><span class="line">import org.w3c.dom.Node; </span><br><span class="line">import org.w3c.dom.NodeList; </span><br><span class="line">import org.xml.sax.SAXException; </span><br><span class="line"> </span><br><span class="line">public class DOMParser &#123; </span><br><span class="line">  DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance(); </span><br><span class="line">  //Load and parse XML file into DOM </span><br><span class="line">  public Document parse(String filePath) &#123; </span><br><span class="line">     Document document = null; </span><br><span class="line">     try &#123; </span><br><span class="line">        //DOM parser instance </span><br><span class="line">        DocumentBuilder builder = builderFactory.newDocumentBuilder(); </span><br><span class="line">        //parse an XML file into a DOM tree </span><br><span class="line">        document = builder.parse(new File(filePath)); </span><br><span class="line">     &#125; catch (ParserConfigurationException e) &#123; </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">     &#125; catch (SAXException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">     &#125; catch (IOException e) &#123; </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">     &#125; </span><br><span class="line">     return document; </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">  public static void main(String[] args) &#123; </span><br><span class="line">        DOMParser parser = new DOMParser(); </span><br><span class="line">        Document document = parser.parse(&quot;books.xml&quot;); </span><br><span class="line">        //get root element </span><br><span class="line">        Element rootElement = document.getDocumentElement(); </span><br><span class="line"> </span><br><span class="line">        //traverse child elements </span><br><span class="line">        NodeList nodes = rootElement.getChildNodes(); </span><br><span class="line">        for (int i=0; i &lt; nodes.getLength(); i++) </span><br><span class="line">        &#123; </span><br><span class="line">           Node node = nodes.item(i); </span><br><span class="line">           if (node.getNodeType() == Node.ELEMENT_NODE) &#123;   </span><br><span class="line">              Element child = (Element) node; </span><br><span class="line">              //process child element </span><br><span class="line">           &#125; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        NodeList nodeList = rootElement.getElementsByTagName(&quot;book&quot;); </span><br><span class="line">        if(nodeList != null) </span><br><span class="line">        &#123; </span><br><span class="line">           for (int i = 0 ; i &lt; nodeList.getLength(); i++) </span><br><span class="line">           &#123; </span><br><span class="line">              Element element = (Element)nodeList.item(i); </span><br><span class="line">              String id = element.getAttribute(&quot;id&quot;); </span><br><span class="line">           &#125; </span><br><span class="line">        &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，DOMParser 的 Parse() 方法负责解析 XML 文件并生成对应的 DOM Document 对象。其中 DocumentBuilderFactory 用于生成 DOM 文档解析器以便解析 XML 文档。 在获取了 XML 文件对应的 Document 对象之后，我们可以调用一系列的 API 方便的对文档对象模型中的元素进行访问和处理。 需要注意的是调用 Element 对象的 getChildNodes() 方法时将返回其下所有的子节点，其中包括空白节点，因此需要在处理子 Element 之前对节点类型加以判断。</p>
<p>可以看出 DOM 解析 XML 易于开发，只需要通过解析器建立起 XML 对应的 DOM 树型结构后便可以方便的使用 API 对节点进行访问和处理，支持节点的删除和修改等。 但是 DOM 解析 XML 文件时会将整个 XML 文件的内容解析成树型结构存放在内存中，因此不适合用 DOM 解析很大的 XML 文件。</p>
<p>SAX 解析 XML</p>
<p>与 DOM 建立树形结构的方式不同，SAX 采用事件模型来解析 XML 文档，是解析 XML 文档的一种更快速、更轻量的方法。 利用 SAX 可以对 XML 文档进行有选择的解析和访问，而不必像 DOM 那样加载整个文档，因此它对内存的要求较低。 但 SAX 对 XML 文档的解析为一次性读取，不创建任何文档对象，很难同时访问文档中的多处数据。</p>
<p>下面是一个 SAX 解析 XML 的例子：</p>
<p>清单 3. SAX 解析 XML</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import org.xml.sax.Attributes; </span><br><span class="line">import org.xml.sax.SAXException; </span><br><span class="line">import org.xml.sax.XMLReader; </span><br><span class="line">import org.xml.sax.helpers.DefaultHandler; </span><br><span class="line">import org.xml.sax.helpers.XMLReaderFactory; </span><br><span class="line"> </span><br><span class="line">public class SAXParser &#123; </span><br><span class="line"> </span><br><span class="line">  class BookHandler extends DefaultHandler &#123; </span><br><span class="line">     private List&lt;String&gt; nameList; </span><br><span class="line">     private boolean title = false; </span><br><span class="line">   </span><br><span class="line">     public List&lt;String&gt; getNameList() &#123; </span><br><span class="line">        return nameList; </span><br><span class="line">     &#125; </span><br><span class="line">     // Called at start of an XML document </span><br><span class="line">     @Override </span><br><span class="line">     public void startDocument() throws SAXException &#123; </span><br><span class="line">        System.out.println(&quot;Start parsing document...&quot;); </span><br><span class="line">        nameList = new ArrayList&lt;String&gt;(); </span><br><span class="line">     &#125; </span><br><span class="line">     // Called at end of an XML document </span><br><span class="line">     @Override </span><br><span class="line">     public void endDocument() throws SAXException &#123;  </span><br><span class="line">        System.out.println(&quot;End&quot;);  </span><br><span class="line">     &#125; </span><br><span class="line">      </span><br><span class="line">     /** </span><br><span class="line">      * Start processing of an element. </span><br><span class="line">      * @param namespaceURI  Namespace URI </span><br><span class="line">      * @param localName  The local name, without prefix </span><br><span class="line">      * @param qName  The qualified name, with prefix </span><br><span class="line">      * @param atts  The attributes of the element </span><br><span class="line">      */ </span><br><span class="line">     @Override </span><br><span class="line">     public void startElement(String uri, String localName, String qName, </span><br><span class="line">        Attributes atts) throws SAXException &#123; </span><br><span class="line">        // Using qualified name because we are not using xmlns prefixes here. </span><br><span class="line">        if (qName.equals(&quot;title&quot;)) &#123; </span><br><span class="line">           title = true; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">   </span><br><span class="line">     @Override </span><br><span class="line">     public void endElement(String namespaceURI, String localName, String qName) </span><br><span class="line">        throws SAXException &#123; </span><br><span class="line">        // End of processing current element </span><br><span class="line">        if (title) &#123; </span><br><span class="line">           title = false; </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">            </span><br><span class="line">     @Override </span><br><span class="line">     public void characters(char[] ch, int start, int length) &#123; </span><br><span class="line">        // Processing character data inside an element </span><br><span class="line">        if (title) &#123; </span><br><span class="line">           String bookTitle = new String(ch, start, length); </span><br><span class="line">           System.out.println(&quot;Book title: &quot; + bookTitle); </span><br><span class="line">           nameList.add(bookTitle); </span><br><span class="line">        &#125; </span><br><span class="line">     &#125; </span><br><span class="line">            </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">  public static void main(String[] args) throws SAXException, IOException &#123; </span><br><span class="line">     XMLReader parser = XMLReaderFactory.createXMLReader(); </span><br><span class="line">     BookHandler bookHandler = (new SAXParser()).new BookHandler(); </span><br><span class="line">     parser.setContentHandler(bookHandler); </span><br><span class="line">     parser.parse(&quot;books.xml&quot;); </span><br><span class="line">     System.out.println(bookHandler.getNameList()); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SAX 解析器接口和事件处理器接口定义在 org.xml.sax 包中。主要的接口包括 ContentHandler、DTDHandler、EntityResolver 及 ErrorHandler。 其中 ContentHandler 是主要的处理器接口，用于处理基本的文档解析事件；DTDHandler 和 EntityResolver 接口用于处理与 DTD 验证和实体解析相关的事件； ErrorHandler 是基本的错误处理接口。DefaultHandler 类实现了上述四个事件处理接口。上面的例子中 BookHandler 继承了 DefaultHandler 类， 并覆盖了其中的五个回调方法 startDocument()、endDocument()、startElement()、endElement() 及 characters() 以加入自己的事件处理逻辑。</p>
<p>Digester 解析 XML</p>
<p>为了满足将 XML 转换为 JavaBean 的特殊需求，Apache 旗下的一个名为 Digester 的工具为我们提供了这么一个选择。由于最终是将 XML 转化为 JavaBean 存储在内存当中， 故而解析性能等方面其实与使用者并没有多大关系。解析的关键在于用以匹配 XML 的模式以及规则等，由于该工具较为复杂，限于篇幅，作者只能给予简单的介绍。</p>
<p>下面是一个 Digester 解析 XML 的例子片段：</p>
<p>清单 4. Digester 解析 XML</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 定义要解析的 XML 的路径，并初始化工具类</span><br><span class="line">File input = new File(&quot;books.xml&quot;); </span><br><span class="line">Digester digester = new Digester(); </span><br><span class="line"> </span><br><span class="line">// 如果碰到了 &lt;books&gt; 这个标签，应该初始化 test.myBean.Books 这个 JavaBean 并填装相关内容</span><br><span class="line">digester.addObjectCreate(&quot;books&quot;, &quot;test.myBean.Books&quot;); </span><br><span class="line">digester.addSetProperties(&quot;books&quot;); </span><br><span class="line">// 如果碰到了 &lt;books/book&gt; 这个标签，同上初始化 test.myBean.Book 这个 JavaBean </span><br><span class="line">digester.addObjectCreate(&quot;books/book&quot;, &quot;test.myBean.Book&quot;); </span><br><span class="line">digester.addSetProperties(&quot;books/book&quot;); </span><br><span class="line">// 通过调用上面已经初始化过的 JavaBean 的 addBook() 方法来把多个 &lt;books/book&gt; 加到一个集合中</span><br><span class="line">digester.addSetNext(&quot;books/book&quot;, &quot;addBook&quot;, &quot;test.myBean.Book&quot;); </span><br><span class="line"> </span><br><span class="line">// 定义好了上面的解析规则后，就可以开始进行解析工作了</span><br><span class="line">Books books = (Books) digester.parse(input);</span><br></pre></td></tr></table></figure>
<p>上述代码简单的向读者展示了 Digester 处理 XML 的一些要点，主要是说明了一些模式以及规则的匹配。 简言之，Digester 就是一种用来把一个 XML 转化为一个与该 XML 结构类似的 JavaBean。你可以把 XML 根元素想象成一个 JavaBean， 该根元素的 attribute 就是这个 JavaBean 的各种 Field，当该根元素有其他子 tag 时，又要把这个子 tag 想象成一个个新的 XML，将其视为一个新的 JavaBean， 并作为一个 Field 加入到父 Bean 当中，然后以此类推，通过循环的方式将整个 XML 进行解析。</p>
<p>结束语<br><br>本文介绍了 Java 解析 XML 的三种常用技术，其中 DOM 易于上手，程序易于理解，但缺点在于占用内存大，不适合于解析较大的 XML 文件； SAX 基于事件模型占用系统资源少，能够胜任较大的 XML 文件解析，但解析过程较为繁琐查找元素不方便； Digester/JAXB 基于上述两种技术衍生而来。文中的实例向读者展示了三种 API 的基本使用方法， 在实际开发过程中使用那种技术解析 XML 更好要依据各自的优缺点视具体情况而定。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.shengfq.github.io/2018/09/23/遗留系统的异常处理办法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="盛富强">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shengfq's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/23/遗留系统的异常处理办法/" itemprop="url">遗留系统的异常处理办法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-23T19:43:27+08:00">
                2018-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h5>遗留系统的异常处理办法</h5><p></p>
<p></p><h5>背景</h5><br>OA7.0是一个跨度较大的版本，拷贝了客户生产环境的webapp/resources/data 就可以在本地搭建其测试环境。<br>根据客户的二开策略，我修改了数据源等个性化配置信息后遇到了些问题：<br>1.启动报各种异常导致无法启动成功<br>2.启动成功后，使用用户名和密码都无法登录成功<br>在这种情形下，就要进入具体的报错点，熟悉类的加载过程。<p></p>
<pre>java.lang.NoClassDefFoundError: Could not initialize class org.springside.core.Constants

Oracle 的解释是：
Thrown if the Java Virtual Machine or a ClassLoader instance tries to load in the definition of a class (as part of a normal method call or as part of creating a new instance using the new expression) and no definition of the class could be found.
The searched-for class definition existed when the currently executing class was compiled, but the definition can no longer be found.

当java虚拟机或者类加载器实例尝试加载定义的类时，却没有找到该类的定义。
</pre>

<p></p><h5>解决思路</h5><p></p>
<p></p><p>注释法</p><br>类会先加载static块，采用二分法的方式注释一部分方法调用，看问题是否存在。<p></p>
<p></p><p>日志法</p><br>生产环境的问题无法debug，但是可以通过详细的日志调用，知道执行了哪些问题。<p></p>
<p></p><p>反编译法</p><br>因为jar包里面的代码无法打断点，可以将类反编译出来，jdk会优先调用classes目录的字节码。<p></p>
<p></p><p>异常定位法</p><br>既然是抛出了异常导致启动不成功，那么异常是哪里引起的，可以通过增加try…catch来捕获异常，定位异常点，记录异常信息。<p></p>
<p></p><h5>最终解决</h5><br>原来是Constants类调用了Lisences.jar里面的方法导致抛出异常而没有处理，导致程序异常中断，static块没有执行完成，类加载器无法<br>初始化Constants实例。所以遗留系统里面的问题就是写了大量的没有异常处理机制的代码，既没有自主处理异常，也没有抛出异常，告知调用者<br>可能会出现的异常，通过上述的四个方法基本上可以找到问题点，解决之。<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">盛富强</p>
              <p class="site-description motion-element" itemprop="description">blogs and research</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.github.com/shengfq" target="_blank" title="github">
                      
                        <i class="fa fa-fw fa-globe"></i>github</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">盛富强</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
